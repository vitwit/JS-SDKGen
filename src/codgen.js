import chalk from "chalk";
import fs from "fs";
import {
  stringOne,
  functionSignature,
  endString,
  markdownStartString,
  appendModalLink,
  markdownCodeBlockEnd,
  operationMarkdownEnd,
  responseMarkdown
} from "./codeStrings";
import {
  extractPathParams,
  toCamelCase,
  toTitleCase,
  getDefinitionKey,
  removeKeys
} from "./utils";
import cp from "cp";

/**
 *
 * fn isDocJson
 * Checks if the given json is of apidocjs style
 * 
 * @param {*} json
 * @returns true / false
 */
const isDocJson = json => {
  const api = json && json[0];

  return api && api.type && api.url && api.name && api.parameter.fields;
};

/**
 *
 * fn isSwaggerJson
 * Checks if given json file is of swagger style
 * 
 * @param {*} json
 * @returns true / false
 */
const isSwaggerJson = json => {
  return json && json.swagger;
};

/**
 *
 *
 * fn stringifyObj
 * Stringifies the given object (multi-level)
 * 
 * @param {*} obj
 */
const stringifyObj = obj =>
  Object.keys(obj)
    .map(key => {
      return `${key}:${
        typeof obj[key] !== "object" ? obj[key] : JSON.stringify(obj[key])
        }`;
    })
    .join()
    .replace(/:/g, "-");

/**
 *
 *
 * fn generateSDK
 * Generates SDK file and documentation from given config
 * 
 * @export
 * @param {*} {
 *   jsonFile,
 *   jsFile,
 *   baseUrl = "",
 *   name = "yournameSDK",
 *   version,
 *   requiredHeaders = [],
 *   optionalHeaders = []
 * }
 */
export function generateSDK({
  jsonFile,
  jsFile,
  baseUrl = "",
  name = "yournameSDK",
  version,
  requiredHeaders = [],
  optionalHeaders = []
}) {
  let _jsonFile;

  // Format given SDK name to title case
  const _name = toTitleCase(name);

  // reading through cli will only have absolute path
  if (jsonFile) {
    _jsonFile = JSON.parse(fs.readFileSync(jsonFile, "utf8"));
  }

  let _transformJson = a => a;

  let _transformOperations = {};

  if (jsFile) {
    const { transformOperations, transformJson } = require(jsFile);

    _transformJson = transformJson;

    _transformOperations = transformOperations;
  }

  // if the given file is generated by swagger
  const isSwaggerGenerated = isSwaggerJson(_jsonFile);

  // if the given file is generated by apidocjs
  const isDocGenerated = isDocJson(_jsonFile);

  // Array to store the generated code
  const arrSDKCode = [];

  // Array to store the generated SDK documentation
  const arrSDKDoc = [];

  // Initialize SDK code with SDK name, version, baseUrl, headers, transformOperations
  arrSDKCode.push(
    stringOne({
      version,
      sdkName: _name,
      baseUrl,
      transformOperations: !!_transformOperations,
      requiredHeaders,
      optionalHeaders
    })
  );

  try {
    if (!isDocGenerated && !isSwaggerGenerated) {
      const formatedJson = _transformJson(_jsonFile);

      formatedJson.forEach(
        ({ operationName, url, requestMethod, isFormData }) => {
          const operationFunction = functionSignature({
            hasPathParams: extractPathParams(url).length,
            operationName,
            transformResponse: _transformOperations[operationName],
            url,
            requestMethod: requestMethod.toUpperCase(),
            isFormData
          });

          arrSDKCode.push(operationFunction);
        }
      );
    } else if (isSwaggerGenerated) {
      const pathsData = _jsonFile.paths;

      Object.entries(pathsData).map(path => {
        const url = path[0];

        Object.entries(path[1]).forEach(method => {
          const requestMethod = method[0];

          const methodData = method[1];

          const operationName = methodData.operationId;

          const consumes = methodData.consumes || [];

          const isFormData = consumes.includes("multipart/form-data");

          const thisOperationBodyParamsModals = [];

          const thisOperationResponesModals = [];

          const bodyParamsDocGenerators = params => {
            // lets group body/formData params,path params and query params together
            //
            const body = params.filter(param =>
              ["body", "formData"].includes(param.in) ? param : false
            );

            const pathParams = params.filter(param => param.in === "path");

            const qparams = params.filter(param => param.in === "query");

            //
            arrSDKDoc.push(markdownStartString({ operationName, name }));

            // can't destruct "in" params bcoz a reserved keyword;
            body.forEach(({ name, schema, type, ...other }) => {
              // if name is body indicates it has a params for which a modal exist in definations
              //  so we just comment meta info here and link to that modal below example code

              if (name === "body") {
                // const definition =
                //   _jsonFile.definitions[getDefinitionKey(schema)];

                arrSDKDoc.push(
                  `  /** ${getDefinitionKey(schema)} modal,${
                  schema.type ? "type - " + schema.type + "," : ""
                  } ${stringifyObj(removeKeys(other, "in"))} */`
                );

                thisOperationBodyParamsModals.push(getDefinitionKey(schema));
              } else {
                // else just name: type of param, stringify other info and comment // if there is a object in other info just JSON.stringify
                arrSDKDoc.push(
                  ` ${name}:${type}, /** ${stringifyObj({
                    ...removeKeys(other, "in")
                  })} */\n`
                );
              }
            });

            if (pathParams.length) {
              arrSDKDoc.push("  _pathParams: {\n");

              pathParams.forEach(({ name, type, ...other }) => {
                arrSDKDoc.push(
                  `   ${name}:${type}, /** ${stringifyObj({
                    ...removeKeys(other, "in")
                  })} */ \n`
                );
              });

              arrSDKDoc.push("  }");
            }

            if (qparams.length) {
              arrSDKDoc.push("  _params: {\n");

              qparams.forEach(({ name, type, ...other }) => {
                arrSDKDoc.push(
                  `   ${name}:${type}, /** ${stringifyObj({
                    ...removeKeys(other, "in")
                  })} */ \n`
                );
              });

              arrSDKDoc.push("  }");
            }

            arrSDKDoc.push(markdownCodeBlockEnd());
          };

          const responsesDocsGenerators = responses => {
            const twoXX = {};

            const fourXX = {};

            const fiveXX = {};

            const defaultResponse = {};

            Object.keys(responses).forEach(key => {
              if (responses[key] && responses[key].schema) {
                thisOperationResponesModals.push(
                  getDefinitionKey(responses[key].schema)
                );
              }

              if (key.includes("20")) {
                twoXX[key] = responses[key];
              }

              if (key.includes("40")) {
                fourXX[key] = responses[key];
              }

              if (key.includes("50")) {
                fiveXX[key] = responses[key];
              }

              if (key.includes("default")) {
                defaultResponse[key] = responses[key];
              }
            });

            arrSDKDoc.push(
              `\n**Responses**\n
              `
            );

            if (Object.keys(defaultResponse).length) {
              arrSDKDoc.push(
                responseMarkdown({ resCode: "Default", json: defaultResponse })
              );
            }

            if (Object.keys(twoXX).length) {
              arrSDKDoc.push(
                responseMarkdown({ resCode: "Success 2XX", json: twoXX })
              );
            }

            if (Object.keys(fourXX).length) {
              arrSDKDoc.push(
                responseMarkdown({ resCode: "Error 4XX", json: fourXX })
              );
            }

            if (Object.keys(fiveXX).length) {
              arrSDKDoc.push(
                responseMarkdown({ resCode: "Error 5XX", json: fiveXX })
              );
            }
          };

          bodyParamsDocGenerators(methodData.parameters);

          responsesDocsGenerators(methodData.responses);

          const thisOperationsModals = [
            ...thisOperationBodyParamsModals,
            ...thisOperationResponesModals
          ];

          if (thisOperationsModals.length) {
            arrSDKDoc.push("\n###### ");

            thisOperationsModals.forEach(a =>
              arrSDKDoc.push(appendModalLink(a))
            );
          }

          arrSDKDoc.push(operationMarkdownEnd());

          const operationFunction = functionSignature({
            hasPathParams: extractPathParams(url).length,
            operationName,
            transformResponse: _transformOperations[operationName],
            url,
            requestMethod: requestMethod.toUpperCase(),
            isFormData
          });

          arrSDKCode.push(operationFunction);
        });
      });
    } else if (isDocGenerated) {
      _jsonFile.map(api => {
        const url = api.url;

        const requestMethod = api.type;

        const operationName = toCamelCase(api.name);

        const isFormData =
          api.parameter &&
          api.parameter.fields &&
          Object.entries(api.parameter.fields)
            .map(arr => arr[0])
            .includes("Request formdata");

        const operationFunction = functionSignature({
          hasPathParams: extractPathParams(url).length,
          operationName,
          transformResponse: _transformOperations[operationName],
          url,
          requestMethod: requestMethod.toUpperCase(),
          isFormData
        });

        arrSDKCode.push(operationFunction);
      });
    } else {
      console.error(
        "%s The file doesn't seem to be generated by swagger or apidocjs, you can provide a js file with custom funtion to resolve given json.",
        chalk.red.bold("ERROR")
      );

      process.exit(1);
    }
  } catch (err) {
    console.log(err);

    if (!(isDocGenerated && isSwaggerGenerated)) {
      console.error(
        "%s The file doesn't seem to be generated by swagger or apidocjs, you can provide a js file with custom funtion to resolve given json.",
        chalk.red.bold("ERROR")
      );

      process.exit(1);
    } else {
      console.log(err);

      console.error("%s error in json", chalk.red.bold("ERROR"));

      process.exit(1);
    }
  }

  if (isSwaggerGenerated) {
    const generateModalsReadeMe = json => {
      const definitions = json.definitions;

      arrSDKDoc.push("\n# Modal Definations\n");

      Object.keys(definitions).forEach(key => {
        arrSDKDoc.push(
          `\n ### ${key}-modal\n \`\`\`json\n${JSON.stringify(
            definitions[key],
            null,
            2
          )}\n\`\`\`\n`
        );
      });
    };

    generateModalsReadeMe(_jsonFile);
  }

  arrSDKCode.push(endString);

  const dir = "sdk"; //output directory

  // Create sdk directory if it doesn't exists
  if (!fs.existsSync(dir)) {
    fs.mkdirSync(dir);
  }

  if (jsFile) {
    cp(jsFile, "sdk/transformOperations.js", (err, res) => {
      if (err) { throw err; }
    });
  }

  // Save the documentation to README.md file inside sdk folder
  fs.writeFile("sdk/README.md", arrSDKDoc.join(""), err => {
    if (err) { throw err; }
  });

  // Save the SDK code to given name inside sdk folder
  fs.writeFile("sdk/" + name + ".js", arrSDKCode.join(""), err => {
    if (err) { throw err; }
  });
}
